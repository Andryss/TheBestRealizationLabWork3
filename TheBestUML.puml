@startuml
'Текст задания:
'
'Издательская компания «Эксмо» совместно с Hoff представила данные по
'книжным предпочтениям россиян в 2021 году: абсолютным лидером продаж
'стали книги (издание и переиздание) Михаила Лабковского «Хочу и буду»,
'сообщили в пресс-службе.
'
'Книги психолога лидировали по продажам по всей стране: за год было
'продано более 129 тыс. экземпляров первого издания и 34,5 тыс. второго.
'
'На втором месте по популярности у покупателей детектив «Внутри убийцы»
'израильского писателя Майка Омера (более 92 тыс. экземпляров) про
'криминального психолога-женщину, расследующую череду жестоких
'преступлений. Тройку лидеров продаж замыкает роман «Transhumanism inc.»
'Виктора Пелевина — новинка российского автора разошлась в количестве 71
'тыс. экземпляров.

enum Genre {
ADVENTURE("приключенческая книга")
VISUAL_NOVEL("визуальная новелла")
DETECTIVE("детектив")
DRAMA("драма")
FANTASY("фантастика")
HISTORICLAL("историческая книга")
PSYCHOLOGIC("психологическая книга")
--Fields--
- final String name
--Constructors--
Genre(String name)
--Methods--
'dont understand "collision problem"
'I think all is OK
+ static getRandomGenre() : Genre
+ getName() : String
}

'i have an idea how to create Person[]
enum Country{
USSR("USSR",290_938_469)
...
(here will be more countries)
--Fields--
- String name
- int population
'persons-heap :)
- Person[] people
--Constructors--
Country(String name, int population)
--Methods--
'in this method we will create Person[]
'name of method must be better
+ placeInitialization() : void
'in this method we will append Person in Persons-heap
+ add(Person person) : void
+ (getters)
}

interface Readable {
--Methods--
'this method will return info about readable
'so Book.read() should return String with author, title, genre, about fields
read() : String
}

class Book implements Readable {
--Fields--
'delete year field
- String author
- String title
- Genre genre
- int edition
- String about
--Constructors--
Book(String author, String title, Genre genre, int edition, String about)
--Methods--
'there is the method, which mix all info
'about book in one String and return it
+ read(): String
'it is read, because Readable
+ (getters)
}


abstract class Person {
--Fields--
- String name
--Methods--
+ getName() : String
+ abstract whatYouBuy(Readable[] readable): Readable[]
+ abstract choseBest(Readable[] readable): Readable
+ abstract choseWorst(Readable[] readable): Readable
}

abstract class Publisher {
--Fields--
- String name
--Constructors--
Publisher(String name)
--Methods--
'i think it should be void but print all info in stdout
'this method should ask all people in the World about Readable[]
+ publish(World, Readable[]): void
- (some private help-methods)
- (abstract method)
}

'names must be better
class Publisher1 extends Publisher {
'publisher which invokes whatYouBuy method
}

class Publisher2 extends Publisher {
'publisher which invokes choseBest method
}

class Publisher3 extends Publisher {
'publisher which invokes choseWorst method
}

class World {
--Fields--
- int year = 0
- Country[] countries
--Constructors--
World(Country[] countries)
--Methods--
'i think publisher must ask persons
'+ makeCountryChoose(Country country): void
'+ getResults(): Book[]
+ (just getters)
}

class TooManyPeopleException extends RuntimeException {
'we want to have more Persons than Person[] can contain
--Fields--
- Country country
- Person person
--Methods--
+ getMessage() : String
}

class PeopleDoesNotCreateException extends RuntimeException {
'we want to add Person and Person[] is null (not created)
--Fields--
- Country country
--Methods--
+ getMessage() : String
}

@enduml
