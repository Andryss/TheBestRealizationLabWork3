@startuml
'Текст задания:
'
'Издательская компания «Эксмо» совместно с Hoff представила данные по
'книжным предпочтениям россиян в 2021 году: абсолютным лидером продаж
'стали книги (издание и переиздание) Михаила Лабковского «Хочу и буду»,
'сообщили в пресс-службе.
'
'Книги психолога лидировали по продажам по всей стране: за год было
'продано более 129 тыс. экземпляров первого издания и 34,5 тыс. второго.
'
'На втором месте по популярности у покупателей детектив «Внутри убийцы»
'израильского писателя Майка Омера (более 92 тыс. экземпляров) про
'криминального психолога-женщину, расследующую череду жестоких
'преступлений. Тройку лидеров продаж замыкает роман «Transhumanism inc.»
'Виктора Пелевина — новинка российского автора разошлась в количестве 71
'тыс. экземпляров.

enum Genre {
ADVENTURE("приключенческая книга")
VISUAL_NOVEL("визуальная новелла")
DETECTIVE("детектив")
DRAMA("драма")
FANTASY("фэнтези"),
SCIENCE_FICTION("научная фантастика"),
HISTORICAL("историческая книга"),
PSYCHOLOGIC("психологическая книга");
--Fields--
- final String name
--Constructors--
Genre(String name)
--Methods--
+ static getRandomGenre() : Genre
+ static getRandomGenres() : Genre[]
+ getName() : String
}


class Country{
--Fields--
- String name
- int population
- Person[] people
- boolean anarchyFlag
+ static int MAX_POPULATION = 1e6 + 1;
--Constructors--
Country(String name, int population)
--Methods--
+ getName(): String
+ getPopulation(): int
+ isAnarchy(): boolean
+ getPeople() : Person[]
--InnerClasses--
static class CountryFactory
}


class CountryFactory {
+ static initializationRandom(String name, int population): Country
- static imigration(Country thisCountry): void
+ static initialization(String name, int population): Country
}

Country +-- CountryFactory


interface Readable {
--Methods--
'this method will return info about readable
'so TheBestLab4.Book.read() should return String with author, title, genre, about fields
read() : String
}


class Book implements Readable {
--Fields--
- String author
- String title
- Genre genre
- String about
--Constructors--
Book(String author, String title, Genre genre, String about)
Book(String author, String title, Genre genre)
--Methods--
+ read(): String
+ getGenre(): Genre
+ getAbout(): String
+ getAuthor(): String
+ getTitle(): String
}


class Person {
--Fields--
- final static String[] names;
- String name
- Genre[] favouriteGenres
--Methods--
+ static getRandomName(): String
+ static getRandomPerson() : Person
+ getName() : String
+ getFavouriteGenres(): Genre[]
+ whatYouBuy(Readable[] readable): Readable[]
+ choseBest(Readable[] readable): Readable
+ choseWorst(Readable[] readable): Readable
}


abstract class Publisher {
--Fields--
- String name
--Constructors--
Publisher(String name)
--Methods--
+ abstract publish(World world, Readable[] readables, PublishOption option) : void
# abstract surveyCountry(Country country, Readable[] readables) : Map<Readable, Integer>
# surveyWorld(World world, Readable[] readables) : Map<Readable, Integer>
# abstract printResult(Readable[] readables, Map<Readable, Integer> rating) : void
# printCountryResult(Country country, Readable[] readables, Map<Readable, Integer> rating) : void
# printWorldResult(Readable[] readables, Map<Readable, Integer> rating) : void
+ getName() : String
}


enum PublishOption {
IN_EACH_COUNTRY,
ALL_AROUND_THE_WORLD
}

Publisher +-- PublishOption


'publisher, which invokes whatYouBuy
class PurchasingPublisher extends Publisher {
--Fields--
--Constructors--
TheBestPublisher(String name)
--Methods--
# surveyCountry(Country country, Readable[], readables): Map<Readable, Integer>
# printResult(Readable[] readables, Map<Readable, Integer> rating) : void
+ publish(World world, Readable[] readables, PublishOption option): void
}


abstract class ChoosingPublisher extends Publisher {
--Fields--
--Constructors--
ChoosingPublisher(String name)
--Methods--
# abstract invokePersonMethod(Person person, Readable[] readables)
# surveyCountry(Country country, Readable[], readables): Map<Readable, Integer>
+ publish(World world, Readable[] readables): void
}


'publisher which invokes choseBest method
class ChoosingBestPublisher extends ChoosingPublisher {
--Fields--
--Constructors--
ChoosingBestPublisher(String name)
--Methods--
# invokePersonMethod(Person person, Readable[] readables) : Readable
# printResult(Readable[] readables, Map<Readable, Integer> rating) : void
}


'publisher which invokes choseWorst method
class ChoosingWorstPublisher extends ChoosingPublisher {
--Fields--
--Constructors--
ChoosingBestPublisher(String name)
--Methods--
# invokePersonMethod(Person person, Readable[] readables) : Readable
# printResult(Readable[] readables, Map<Readable, Integer> rating) : void
}


class World {
--Fields--
- int year
- Country[] countries
- static final WORLD
--Constructors--
- World()
--Methods--
+ static newInstance(int year, Country[] countries): World
+ getCountries() : Country[]
+ getYear() : int
}


class TooManyPeopleException extends Exception {
'there may be overpopulation in country
--Fields--
- Country country
- Person person
--Constructors--
TooManyPeopleException(Country country, Person person)
(other constructors)
--Methods--
+ getMessage() : String
}


class CountyIsAnarchyException extends RuntimeException {
'County can't return People[] if anarchy
--Fields--
- Country country
--Constructors--
CountyIsAnarchyException(Country country)
(other constructors)
--Methods--
+ getMessage() : String
}


class CountryInitializationException extends RuntimeException {
'Country can't set People[] if user gives wrong length of People[]
--Fields--
- String country
- int population
--Constructors--
CountryInitializationException(String name, int population)
--Methods--
+ getMessage() : String
}

@enduml
